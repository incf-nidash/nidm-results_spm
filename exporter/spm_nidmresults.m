function [nidmfile, prov] = spm_nidmresults(NIDM, outdir)
% Export SPM stats results using the Neuroimaging Data Model (NIDM)
% FORMAT [nidmfile, prov] = spm_results_nidm(NIDM, outdir)
% NIDM     - NIDM minimal JSON structure
% outdir   - output directory
%
% nidmfile - output NIDM zip archive filename
% prov     - provenance object (see spm_provenance.m)
%__________________________________________________________________________
% References:
% 
% Neuroimaging Data Model (NIDM):
%   http://nidm.nidash.org/
%
% PROV-DM: The PROV Data Model:
%   http://www.w3.org/TR/prov-dm/
%__________________________________________________________________________
% Copyright (C) 2013-2017 Wellcome Trust Centre for Neuroimaging

% Guillaume Flandin, Camille Maumet
% $Id: spm_results_nidm.m 6903 2016-10-12 11:36:41Z guillaume $

%-Options
%==========================================================================

%-General options
%--------------------------------------------------------------------------
gz           = '.gz';                        %-Compressed NIfTI {'.gz', ''}

%==========================================================================
%-Populate output directory
%==========================================================================
if nargin < 2, outdir = pwd; end
outdir       = tempname(outdir);
sts          = mkdir(outdir);
if ~sts, error('Cannot create directory "%s".',outdir); end

spm_jsonwrite('nidm_minimal.json', NIDM, struct('indent',blanks(4)));

%-Design Matrix image (as png and csv)
%--------------------------------------------------------------------------
DesMtxValue  = NIDM.DesignMatrix_value;
reg_names    = NIDM.DesignMatrix_regressorNames;

files.desimg = fullfile(outdir,'DesignMatrix.png');

xX.nKX       = spm_DesMtx('sca',DesMtxValue,reg_names);
DesMtx       = (xX.nKX + 1)*32;
% ml           = floor(size(DesMtx,1)/size(DesMtx,2));
% DesMtx       = reshape(repmat(DesMtx,ml,1),size(DesMtx,1),[]);
imwrite(DesMtx,gray(64),files.desimg,'png');
files.descsv = fullfile(outdir,'DesignMatrix.csv');
csvwrite(files.descsv,DesMtxValue);

%-Maximum Intensity Projection image (as png)
%--------------------------------------------------------------------------
if isfield(NIDM, 'Inferences')
    con_name   = NIDM.Inferences(1).StatisticMap_contrastName;

    inferences = NIDM.Inferences;
    if numel(inferences) > 1
        warning('Exporter assumes only one inference is reported.')
    end

    inference  = inferences(1);
else
    inferences = NIDM.ConjunctionInferences;
    
    if numel(inferences) > 1
        warning('Exporter assumes only one inference is reported.')
    end

    inference  = inferences(1);
    
    con_name   = inference.StatisticMap_contrastName;
end

if isfield(inference, 'ExcursionSetMap_hasMaximumIntensityProjection')
    has_mip = true;
    files.mip_orig = inference.ExcursionSetMap_hasMaximumIntensityProjection;
    files.mip = spm_file(files.mip_orig, 'path', outdir);
    copyfile(files.mip_orig, files.mip);
else
    has_mip = false;
end

%-Beta images (as NIfTI)
%--------------------------------------------------------------------------
files.beta_orig = NIDM.ParameterEstimateMaps;
regressor_names = NIDM.DesignMatrix_regressorNames;

% if numel(regressor_names) ~= numel(files.beta_orig)
%     disp(regressor_names)
%     disp(files.beta_orig)
%     error('Should have as many regressor names as beta maps')
% end

for i=1:numel(files.beta_orig)
    files.beta{i} = fullfile(outdir,[sprintf('ParameterEstimate_%04d',i) '.nii' gz]);
    img2nii(files.beta_orig{i}, files.beta{i});
end

%-SPM{.}, contrast, contrast standard error, and contrast explained mean square images (as NIfTI)
%--------------------------------------------------------------------------
contrasts = NIDM.Contrasts;

for i=1:numel(contrasts)
    if iscell(contrasts)
        con = contrasts{i};
    else
        con = contrasts(i);
    end
    
    if numel(contrasts) == 1, postfix = '';
    else                    postfix = sprintf('_%04d',i); end
    stat_type = con.StatisticMap_statisticType;
    
    if strcmp(con.StatisticMap_contrastName,con_name{1})
        STAT = stat_type;
    end
    
    if isfield(con, 'StatisticMap_statisticNotation')
        stat = con.StatisticMap_statisticNotation;
    else
        if strcmp(stat_type, 'obo_TStatistic')
            stat = 'T';
        elseif strcmp(stat_type, 'obo_FStatistic')
            stat = 'F';
        else
            warning('nidm:unknownStatType', ...
                ['Unrecognised statistic type.'])
            stat = 'U';
        end
    end

    files.spm{i} = fullfile(outdir,[stat 'Statistic' postfix '.nii' gz]);
    stat_map{i}  = con.StatisticMap_atLocation;
    dof = con.StatisticMap_errorDegreesOfFreedom;
    if stat == 'T'
        info = struct('STAT', 'T', ...
                      'STATstr', ['T_{' num2str(dof) '}'], ...
                      'df', [NaN dof]);
    elseif stat == 'F'
        info = struct('STAT', 'F', ...
                      'STATstr', ['F_{' num2str(dof) '}'], ...
                      'df', dof);
    else
        info = struct('STAT', stat);
    end
    img2nii(spm_file(stat_map{i},'cpath'), files.spm{i}, info);
    
    if stat == 'T'
        files.con{i} = fullfile(outdir,['Contrast' postfix '.nii' gz]);
        files.con_orig{i} = con.ContrastMap_atLocation;
        dof = con.StatisticMap_errorDegreesOfFreedom;
        info = struct('STAT', 'con');
        img2nii(files.con_orig{i}, files.con{i}, info);
        files.conse{i} = fullfile(outdir,['ContrastStandardError' postfix '.nii' gz]);
        files.conse_orig{i} = con.ContrastStandardErrorMap_atLocation;
        img2nii(files.conse_orig{i}, files.conse{i});
    elseif stat == 'F'
        files.effms{i} = fullfile(outdir,['ContrastExplainedMeanSquare' postfix '.nii' gz]);
        files.effms_orig{i} = con.ContrastExplainedMeanSquareMap_atLocation;
        img2nii(files.effms_orig{i}, files.effms{i});
    else
        
    end
end

%-Thresholded SPM{.} image (as NIfTI)
%--------------------------------------------------------------------------
files.tspm = fullfile(outdir,['ExcursionSet.nii' gz]);
excset_map = inference.ExcursionSetMap_atLocation;
img2nii(excset_map, files.tspm);

%-Residual Mean Squares image (as NIfTI)
%--------------------------------------------------------------------------
files.rms = fullfile(outdir,['ResidualMeanSquares.nii' gz]);
files.rms_orig = NIDM.ResidualMeanSquaresMap_atLocation;
img2nii(files.rms_orig, files.rms);

%-Resels per Voxel image (as NIfTI)
%--------------------------------------------------------------------------
has_rpv = false;
if isfield(NIDM, 'ReselsPerVoxelMap_atLocation')
    has_rpv = true;
    files.rpv = fullfile(outdir,['ReselsPerVoxel.nii' gz]);
    files.rpv_orig = NIDM.ReselsPerVoxelMap_atLocation;
    img2nii(files.rpv_orig, files.rpv);
end

%-Analysis mask image (as NIfTI)
%--------------------------------------------------------------------------
files.mask_orig = NIDM.MaskMap_atLocation;
files.mask = fullfile(outdir,['Mask.nii' gz]);
img2nii(files.mask_orig, files.mask);

%-Grand mean image (as NIfTI)
%--------------------------------------------------------------------------
files.grandmean = fullfile(outdir, ['GrandMean.nii' gz]);
gm_map = NIDM.GrandMeanMap_atLocation;
img2nii(gm_map, files.grandmean);
gunzip(files.grandmean);
gunzip(files.mask);
grandMeanMedian = spm_summarise(strrep(files.grandmean, gz, ''),strrep(files.mask, gz, ''),@median);
% In octave the gzipped version is not kept when using gunzip
if ~strcmp(spm_check_version,'matlab')
    gzip(strrep(files.grandmean, '.gz', ''));
    gzip(strrep(files.mask, '.gz', ''));
end
spm_unlink(strrep(files.grandmean, '.gz', ''));
spm_unlink(strrep(files.mask, '.gz', ''));

%-Explicit mask image (as NIfTI)
%--------------------------------------------------------------------------
if isfield(NIDM, 'CustomMap_atLocation')
    files.emask = fullfile(outdir,['CustomMask.nii' gz]);
    cmask_map = NIDM.CustomMap_atLocation;
    img2nii(cmask_map, files.emask);
end

%-Clusters n-ary image (as NIfTI)
%--------------------------------------------------------------------------
if isfield(inference, 'ClusterLabelsMap_atLocation')
    has_clustlabelmap = true;
    files.clust = fullfile(outdir,['ClusterLabels.nii' gz]);
    clust_map = inference.ClusterLabelsMap_atLocation;
    img2nii(clust_map, files.clust);
else
    has_clustlabelmap = false;
end

%-Display mask images (as NIfTI)
%--------------------------------------------------------------------------
if isfield(inference, 'DisplayMaskMap_atLocation')
    files.dmask_orig = inference.DisplayMaskMap_atLocation;
    if ischar(files.dmask_orig)
        files.dmask_orig = {files.dmask_orig};
    end
    for i = 1:numel(files.dmask_orig)
        files.dmask{i} = fullfile(outdir,[sprintf('DisplayMask_%04d.nii',i) gz]);
        img2nii(files.dmask_orig{i}, files.dmask{i})
    end
end

%-SVC Mask (as NIfTI)
%--------------------------------------------------------------------------
% TODO

%-Search Space mask image (as NIfTI)
%--------------------------------------------------------------------------
files.searchspace = fullfile(outdir,['SearchSpaceMask.nii' gz]);
search_map = inference.SearchSpaceMaskMap_atLocation;
img2nii(search_map, files.searchspace)


%==========================================================================
%-                          D A T A   M O D E L
%==========================================================================

clear coordspace originalfile isHumanReadable

niifmt = {'image/nifti','xsd:string'};
isHumanReadable(false);

pp = spm_provenance;

%-Namespaces
%--------------------------------------------------------------------------
pp.add_namespace('nidm','http://purl.org/nidash/nidm#');
pp.add_namespace('niiri','http://iri.nidash.org/');
pp.add_namespace('spm','http://purl.org/nidash/spm#');
pp.add_namespace('neurolex','http://neurolex.org/wiki/');
pp.add_namespace('crypto','http://id.loc.gov/vocabulary/preservation/cryptographicHashFunctions#');
pp.add_namespace('dct','http://purl.org/dc/terms/');
pp.add_namespace('nfo','http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#');
pp.add_namespace('dc','http://purl.org/dc/elements/1.1/');
pp.add_namespace('dctype','http://purl.org/dc/dcmitype/');
pp.add_namespace('obo','http://purl.obolibrary.org/obo/');

%-Provenance
%--------------------------------------------------------------------------
[V,R] = spm('Ver');

idResults = getid('niiri:spm_results_id',isHumanReadable);

if isfield(NIDM, 'NIDMResults_version')
    NIDMversion = NIDM.NIDMResults_version;
    % TODO % should check version and say whether we are able to export 
else
    NIDMversion = '1.3.0';
end
pp.entity(idResults,{...
  'prov:type','prov:Bundle',...
  'prov:type',nidm_conv('nidm_NIDMResults',pp),...
  'prov:label','NIDM-Results',...
  nidm_conv('nidm_version',pp),{NIDMversion,'xsd:string'},...
  });

idExporter = getid('niiri:exporter_id',isHumanReadable);
softVersion = NIDM.NIDMResultsExporter_softwareVersion;
pp.agent(idExporter,{...
    'prov:type',nidm_conv('nidm_spm_results_nidm',pp),...
    'prov:type','prov:SoftwareAgent',...
    'prov:label',{'spm_results_nidm','xsd:string'},...
    nidm_conv('nidm_softwareVersion',pp),{softVersion,'xsd:string'},...
    });

idExport = getid('niiri:export_id',isHumanReadable);
pp.activity(idExport,{...
    'prov:type',nidm_conv('nidm_NIDMResultsExport',pp),...
    'prov:label','NIDM-Results export',...
    });
pp.wasAssociatedWith(idExport, idExporter);
pp.wasGeneratedBy(idResults, idExport, now);

p = spm_provenance;
p.remove_namespace('prov');
p.remove_namespace('xsd');

coordsys = NIDM.CoordinateSpace_inWorldCoordinateSystem;
coordsys = nidm_conv(coordsys,p);

%-Agent: SPM
%--------------------------------------------------------------------------
idSoftware = getid('niiri:software_id',isHumanReadable);
softwareVersion = NIDM.NeuroimagingAnalysisSoftware_softwareVersion;

if isfield(NIDM, 'NeuroimagingAnalysisSoftware_type')
    soft = NIDM.NeuroimagingAnalysisSoftware_type;
    soft_label = NIDM.NeuroimagingAnalysisSoftware_label;
end

p.agent(idSoftware,{...
    'prov:type',nidm_conv(soft,p),...
    'prov:type','prov:SoftwareAgent',...
    'prov:label',{soft_label,'xsd:string'},...
    nidm_conv('nidm_softwareVersion',p),{softwareVersion,'xsd:string'},...
    });

%-Entity: Coordinate Space
%--------------------------------------------------------------------------
units = NIDM.CoordinateSpace_voxelUnits;
gunzip(files.tspm);
excset_img = nifti(strrep(files.tspm, '.gz', ''));
if ~strcmp(spm_check_version,'matlab')
    gzip(strrep(files.tspm, '.gz', ''));
end
spm_unlink(strrep(files.tspm, '.gz', ''))
id_data_coordspace = coordspace(p,excset_img.mat,excset_img.dat.dim,units,coordsys,1);

%-Agent: Scanner
%--------------------------------------------------------------------------
ImagingInstrument = NIDM.ImagingInstrument_type;
switch ImagingInstrument
    case 'nlx_MagneticResonanceImagingScanner'
        ImagingInstrumentLabel = 'MRI Scanner';
    case 'nlx_PositronEmissionTomographyScanner'
        ImagingInstrumentLabel = 'PET Scanner';
    case 'nlx_SinglePhotonEmissionComputedTomographyScanner'
        ImagingInstrumentLabel = 'SPECT Scanner';     
    case 'nlx_ElectroencephalographyMachine'
        ImagingInstrumentLabel = 'EEG Machine';
    case 'nlx_ElectroencephalographyMachine'
        ImagingInstrumentLabel = 'MEG Machine';        
    otherwise
        error('Unknown modality.');
end

idScanner = getid('niiri:mr_scanner_id',isHumanReadable);
p.agent(idScanner,{...
    'prov:type',nidm_conv('nlx_ImagingInstrument',p),...
    'prov:type',nidm_conv(ImagingInstrument,p),...
    'prov:label',{ImagingInstrumentLabel,'xsd:string'},...
    });

%-Agent: Person
%--------------------------------------------------------------------------
if ~isfield(NIDM, 'Groups')
    isgroup = false;
    
    idPerson = getid('niiri:subject_id',isHumanReadable);
    p.agent(idPerson,{...
        'prov:type','prov:Person',...
        'prov:label',{'Person','xsd:string'},...
        });
else
    isgroup = true;
    groups = NIDM.Groups;
    
    %-Agent: Group
    %----------------------------------------------------------------------
    idGroup = cell(1,numel(groups));
    for i=1:numel(groups)
        idGroup{i} = getid(sprintf('niiri:group_id_%d',i),isHumanReadable);
        p.agent(idGroup{i},{...
            'prov:type',nidm_conv('obo_StudyGroupPopulation',p),...
            'prov:label',{sprintf('Group: %s',groups(i).StudyGroupPopulation_groupName),'xsd:string'},...
            nidm_conv('nidm_groupName',p),{groups(i).StudyGroupPopulation_groupName,'xsd:string'},...
            nidm_conv('nidm_numberOfSubjects',p),{groups(i).StudyGroupPopulation_numberOfSubjects,'xsd:int'},...
            });
    end
end

%-Entity: Image Data
%--------------------------------------------------------------------------
if NIDM.Data_grandMeanScaling
    target = NIDM.Data_targetIntensity;
    extra_fields = {...
        nidm_conv('nidm_grandMeanScaling',p),{'true','xsd:boolean'},...
        nidm_conv('nidm_targetIntensity',p),{target,'xsd:float'},...
        };
else
    extra_fields = {...
        nidm_conv('nidm_grandMeanScaling',p),{'false','xsd:boolean'},...
        };
end
if isfield(NIDM, 'Data_hasMRIProtocol')
    mri_protocol = NIDM.Data_hasMRIProtocol;
    extra_fields = {extra_fields{:},...
        nidm_conv('nidm_hasMRIProtocol',p),nidm_conv(mri_protocol,p),...
        };
end
idData = getid('niiri:data_id',isHumanReadable);
p.entity(idData,{...
    'prov:type','prov:Collection',...
    'prov:type',nidm_conv('nidm_Data',p),...
    'prov:label',{'Data','xsd:string'},...
    extra_fields{:}});
p.wasAttributedTo(idData,idScanner);
if ~isgroup
    p.wasAttributedTo(idData,idPerson);
else
    for i=1:numel(groups)
        p.wasAttributedTo(idData,idGroup{i});
    end
end

%-Entity: Drift Model
%--------------------------------------------------------------------------
if isfield(NIDM, 'DesignMatrix_hasDriftModel')
    idDriftModel = getid('niiri:drift_model_id',isHumanReadable);
    
    drift_model = NIDM.DesignMatrix_hasDriftModel;
    
    if strcmp(drift_model, 'spm_DiscreteCosineTransformbasisDriftModel')
        cut_off = NIDM.DesignMatrix_SPMsDriftCutoffPeriod;
        extra_fields = {...
            nidm_conv('spm_SPMsDriftCutoffPeriod',p),...
            {cut_off,'xsd:float'}
        };
    end
    
    p.entity(idDriftModel,{...
        'prov:type',nidm_conv(drift_model,p),...
        'prov:label','SPM''s DCT Drift Model',...
        extra_fields{:};
        });
    extra_fields_drift = {nidm_conv('nidm_hasDriftModel',p),idDriftModel};
else
    extra_fields_drift = {};
end

%-Entity: Design Matrix
%--------------------------------------------------------------------------
idDesignMatrix = getid('niiri:design_matrix_id',isHumanReadable);
idDesignMatrixImage = getid('niiri:design_matrix_png_id',isHumanReadable);

extra_fields_basis_set = {};
if isfield(NIDM, 'DesignMatrix_hasHRFBasis')
    hrf_bases = NIDM.DesignMatrix_hasHRFBasis;
    for h = 1:numel(hrf_bases)
        extra_fields_basis_set(end+1:end+2) = ...
                {nidm_conv('nidm_hasHRFBasis',p),nidm_conv(hrf_bases{h},p)};
    end
end

p.entity(idDesignMatrix,{...
    'prov:type',nidm_conv('nidm_DesignMatrix',p),...
    'prov:location',{uri(spm_file(files.descsv,'cpath')),'xsd:anyURI'},...
    'nfo:fileName',{spm_file(files.descsv,'filename'),'xsd:string'},...
    'dct:format',{'text/csv','xsd:string'},...
    'dc:description',idDesignMatrixImage,...
    'prov:label',{'Design Matrix','xsd:string'},...
    nidm_conv('nidm_regressorNames',p),{nidm_esc(reg_names),'xsd:string'},...
    extra_fields_drift{:},...
    extra_fields_basis_set{:}
    });

p.entity(idDesignMatrixImage,{...
    'prov:type','dctype:Image',...
    'prov:location',{uri(spm_file(files.desimg,'cpath')),'xsd:anyURI'},...
    'nfo:fileName',{spm_file(files.desimg,'filename'),'xsd:string'},...
    'dct:format',{'image/png','xsd:string'},...
    });

%-Entity: Explicit Mask
%--------------------------------------------------------------------------
if isfield(NIDM, 'CustomMap_atLocation')
    has_emask = true;
    
    emask_map = NIDM.CustomMap_atLocation;
    emask_img = nifti(emask_map);
    
    if ~spm_check_orientations(struct('dim',{emask_img.dat.dim,stat_img.dat.dim},...
            'mat',{emask_img.dat.mat,stat_img.mat}),false)
        id_emask_coordspace = coordspace(p,SPM.xM.VM.mat,SPM.xM.VM.dim',...
            units,coordsys);
    else
        id_emask_coordspace = id_data_coordspace;
    end
    idMask2 = getid('niiri:mask_id_2',isHumanReadable);
    p.entity(idMask2,{...
        'prov:type',nidm_conv('nidm_MaskMap',p),... % CustomMaskMap
        'prov:location',{uri(spm_file(files.emask,'cpath')),'xsd:anyURI'},...
        'nfo:fileName',{spm_file(files.emask,'filename'),'xsd:string'},...
        'dct:format',niifmt,...
        'prov:label',{'Custom Mask','xsd:string'},...
        nidm_conv('nidm_inCoordinateSpace',p),id_emask_coordspace,...
        'crypto:sha512',{sha512sum(spm_file(files.emask,'cpath')),'xsd:string'},...
        });
    id = originalfile(p,files.emask,idMask2,nidm_conv('nidm_MaskMap',p)); % CustomMaskMap
    p.wasDerivedFrom(idMask2,id);
else
    has_emask = false;
end

%-Entity: Error Model
%--------------------------------------------------------------------------
err_dep = NIDM.ErrorModel_hasErrorDependence;
err_var_hom = NIDM.ErrorModel_errorVarianceHomogeneous;
if err_var_hom
    err_var_hom = 'true';
else
    err_var_hom = 'false';
end
extra_fields_NM = { ...
    nidm_conv('nidm_hasErrorDependence',p),nidm_conv(err_dep,p),...
    nidm_conv('nidm_errorVarianceHomogeneous',p),{err_var_hom,'xsd:boolean'}...
    };

if isfield(NIDM, 'ErrorModel_varianceMapWiseDependence')
    err_var_dep = NIDM.ErrorModel_varianceMapWiseDependence;
    extra_fields_NM(end+1:end+2) = { ...
        nidm_conv('nidm_varianceMapWiseDependence',p),nidm_conv(err_var_dep,p)
    };
end
if isfield(NIDM, 'ErrorModel_dependenceMapWiseDependence')
    err_dep_dep = NIDM.ErrorModel_dependenceMapWiseDependence;
    extra_fields_NM(end+1:end+2) = { ...
        nidm_conv('nidm_dependenceMapWiseDependence',p),nidm_conv(err_dep_dep,p)
    };
end

est_method = NIDM.ModelParameterEstimation_withEstimationMethod;
extra_fields_PE = {
    nidm_conv('nidm_withEstimationMethod',p),nidm_conv(est_method,p),...
};

err_dist = NIDM.ErrorModel_hasErrorDistribution;
if ~iscell(err_dist)
    err_dist = {err_dist};
end

for i = 1:numel(err_dist)
  extra_fields_NM(end+1:end+2) = { ...
      nidm_conv('nidm_hasErrorDistribution',p),nidm_conv(err_dist{i},p)
  };
end

idErrorModel = getid('niiri:error_model_id',isHumanReadable);
p.entity(idErrorModel,{...
    'prov:type',nidm_conv('nidm_ErrorModel',p),...
    extra_fields_NM{:}});

%-Activity: Model Parameters Estimation
%==========================================================================
idModelPE = getid('niiri:model_pe_id',isHumanReadable);
p.activity(idModelPE,{...
    'prov:type',nidm_conv('nidm_ModelParametersEstimation',p),...
    'prov:label','Model parameters estimation',...
    extra_fields_PE{:}});
p.wasAssociatedWith(idModelPE, idSoftware);
p.used(idModelPE, idDesignMatrix);
p.used(idModelPE, idData);
p.used(idModelPE, idErrorModel);
if has_emask
    p.used(idModelPE, idMask2);
end

%-Entity: Mask Map
%--------------------------------------------------------------------------
idMask1 = getid('niiri:mask_id_1',isHumanReadable);
p.entity(idMask1,{...
    'prov:type',nidm_conv('nidm_MaskMap',p),...
    'prov:location',{uri(spm_file(files.mask,'cpath')),'xsd:anyURI'},...
    nidm_conv('nidm_isUserDefined',p),{'false','xsd:boolean'},...
    'nfo:fileName',{spm_file(files.mask,'filename'),'xsd:string'},...
    'dct:format',niifmt,...
    'prov:label',{'Mask','xsd:string'},...
    nidm_conv('nidm_inCoordinateSpace',p),id_data_coordspace,...
    'crypto:sha512',{sha512sum(spm_file(files.mask,'cpath')),'xsd:string'},...
    });
id = originalfile(p,files.mask_orig,idMask1,nidm_conv('nidm_MaskMap',p));
p.wasDerivedFrom(idMask1,id);
p.wasGeneratedBy(idMask1, idModelPE);

%-Entity: Grand Mean Map
%--------------------------------------------------------------------------
idGrandMean = getid('niiri:grand_mean_map_id',isHumanReadable);
p.entity(idGrandMean,{...
    'prov:type',nidm_conv('nidm_GrandMeanMap',p),...
    'prov:location',{uri(spm_file(files.grandmean,'cpath')),'xsd:anyURI'},...
    'nfo:fileName',{spm_file(files.grandmean,'filename'),'xsd:string'},...
    'dct:format',niifmt,...
    'prov:label',{'Grand Mean Map','xsd:string'},...
    nidm_conv('nidm_maskedMedian',p),{grandMeanMedian,'xsd:float'},...
    nidm_conv('nidm_inCoordinateSpace',p),id_data_coordspace,...
    'crypto:sha512',{sha512sum(spm_file(files.grandmean,'cpath')),'xsd:string'},...
    });
p.wasGeneratedBy(idGrandMean, idModelPE);

%-Entity: Parameter Estimate (Beta) Maps
%--------------------------------------------------------------------------
idBeta = cell(1,numel(files.beta));
for i=1:numel(files.beta_orig)
    idBeta{i} = getid(sprintf('niiri:beta_map_id_%d',i),isHumanReadable);
    p.entity(idBeta{i},{...
        'prov:type',nidm_conv('nidm_ParameterEstimateMap',p),...
        'prov:location',{uri(files.beta{i}),'xsd:anyURI'}...
        'nfo:fileName',{spm_file(files.beta{i},'filename'),'xsd:string'},...
        'dct:format',niifmt,...
        'prov:label',{sprintf('Parameter Estimate Map %d',i),'xsd:string'},...
        nidm_conv('nidm_inCoordinateSpace',p),id_data_coordspace,...
        'crypto:sha512',{sha512sum(files.beta{i}),'xsd:string'},...        
    });
    id = originalfile(p,files.beta_orig{i},idBeta{i},nidm_conv('nidm_ParameterEstimateMap',p));
    p.wasDerivedFrom(idBeta{i},id);
    p.wasGeneratedBy(idBeta{i}, idModelPE);
end

%-Entity: ResMS Map
%--------------------------------------------------------------------------
idResMS = getid('niiri:residual_mean_squares_map_id',isHumanReadable);
p.entity(idResMS,{...
    'prov:type',nidm_conv('nidm_ResidualMeanSquaresMap',p),...
    'prov:location',{uri(spm_file(files.rms,'cpath')),'xsd:anyURI'},...
    'nfo:fileName',{spm_file(files.rms,'filename'),'xsd:string'},...
    'dct:format',niifmt,...
    'prov:label',{'Residual Mean Squares Map','xsd:string'},...
    nidm_conv('nidm_inCoordinateSpace',p),id_data_coordspace,...
    'crypto:sha512',{sha512sum(spm_file(files.rms,'cpath')),'xsd:string'},...
    });
id = originalfile(p,files.rms_orig,idResMS,nidm_conv('nidm_ResidualMeanSquaresMap',p));
p.wasDerivedFrom(idResMS,id);
p.wasGeneratedBy(idResMS, idModelPE);

%-Entity: RPV Map
%--------------------------------------------------------------------------
if has_rpv
    idRPV = getid('niiri:resels_per_voxel_map_id',isHumanReadable);
    p.entity(idRPV,{...
        'prov:type',nidm_conv('nidm_ReselsPerVoxelMap',p),...
        'prov:location',{uri(spm_file(files.rpv,'cpath')),'xsd:anyURI'},...
        'nfo:fileName',{spm_file(files.rpv,'filename'),'xsd:string'},...
        'dct:format',niifmt,...
        'prov:label',{'Resels per Voxel Map','xsd:string'},...
        nidm_conv('nidm_inCoordinateSpace',p),id_data_coordspace,...
        'crypto:sha512',{sha512sum(spm_file(files.rpv,'cpath')),'xsd:string'},...
        });
    id = originalfile(p,files.rpv_orig,idRPV,nidm_conv('nidm_ReselsPerVoxelMap',p));
    p.wasDerivedFrom(idRPV,id);
    p.wasGeneratedBy(idRPV, idModelPE);
end

%-Activity: Contrast Estimation
%==========================================================================
for c=1:numel(contrasts)
    if isstruct(contrasts)
        my_contrast = contrasts(c);
    else
        my_contrast = contrasts{c};
    end
    this_con_name = nidm_esc(my_contrast.StatisticMap_contrastName);
    
    if numel(contrasts) == 1, postfix = '';
    else                      postfix = sprintf('_%d',c); end
    
    this_value = my_contrast.ContrastWeightMatrix_value;
    this_stat_type = my_contrast.StatisticMap_statisticType;
    
    if strcmp(this_stat_type, 'obo_TStatistic')
        this_stat = 'T';
    elseif strcmp(this_stat_type, 'obo_FStatistic')
        this_stat = 'F';
    else
        warning('nidm:unknownStatType', ...
            ['Unrecognised stat type: ' this_stat_type])
        this_stat = 'U';
    end
    
    idConVec = getid(['niiri:contrast_id' postfix],isHumanReadable);
    p.entity(idConVec,{...
        'prov:type',nidm_conv('obo_ContrastWeightMatrix',p),...
        nidm_conv('nidm_statisticType',p),nidm_conv(this_stat_type,p),...
        nidm_conv('nidm_contrastName',p),{nidm_esc(this_con_name),'xsd:string'},...
        'prov:label',{['Contrast: ' nidm_esc(this_con_name)],'xsd:string'},...
        'prov:value',{this_value,'xsd:string'},...
        });

    idConEst = getid(['niiri:contrast_estimation_id' postfix],isHumanReadable);
    p.activity(idConEst,{...
        'prov:type',nidm_conv('nidm_ContrastEstimation',p),...
        'prov:label',['Contrast estimation' strrep(postfix,'_',' ')],...
        });
    p.wasAssociatedWith(idConEst, idSoftware);
    p.used(idConEst, idMask1);
    p.used(idConEst, idResMS);
    p.used(idConEst, idDesignMatrix);
    p.used(idConEst,idConVec);
    for i=1:numel(files.beta_orig)
        p.used(idConEst, idBeta{i});
    end
    
    errdof = my_contrast.StatisticMap_errorDegreesOfFreedom;
    idSPM{c} = getid(['niiri:statistic_map_id' postfix],isHumanReadable);
    p.entity(idSPM{c},{...
        'prov:type',nidm_conv('nidm_StatisticMap',p),...
        'prov:location',{uri(spm_file(files.spm{c},'cpath')),'xsd:anyURI'},...
        'nfo:fileName',{spm_file(files.spm{c},'filename'),'xsd:string'},...
        'dct:format',niifmt,...
        'prov:label',{[upper(this_stat) '-Statistic Map: ' nidm_esc(this_con_name)],'xsd:string'},...
        nidm_conv('nidm_statisticType',p),nidm_conv(this_stat_type,p),...
        nidm_conv('nidm_contrastName',p),{nidm_esc(this_con_name),'xsd:string'},...
        nidm_conv('nidm_errorDegreesOfFreedom',p),{errdof,'xsd:float'},...
        nidm_conv('nidm_effectDegreesOfFreedom',p),{1,'xsd:float'},...
        nidm_conv('nidm_inCoordinateSpace',p),id_data_coordspace,...
        'crypto:sha512',{sha512sum(files.spm{c}),'xsd:string'},...
        });
    id = originalfile(p,stat_map{c},idSPM{c},nidm_conv('nidm_StatisticMap',p));
    p.wasDerivedFrom(idSPM{c},id);
    p.wasGeneratedBy(idSPM{c},idConEst);
    
    if strcmp(this_stat_type, 'obo_TStatistic')
        idContrast = getid(['niiri:contrast_map_id' postfix],isHumanReadable);
        p.entity(idContrast,{...
            'prov:type',nidm_conv('nidm_ContrastMap',p),...
            'prov:location',{uri(spm_file(files.con{c},'cpath')),'xsd:anyURI'},...
            'nfo:fileName',{spm_file(files.con{c},'filename'),'xsd:string'},...
            'dct:format',niifmt,...
            'prov:label',{['Contrast Map: ' nidm_esc(this_con_name)],'xsd:string'},...
            nidm_conv('nidm_contrastName',p),{nidm_esc(this_con_name),'xsd:string'},...
            nidm_conv('nidm_inCoordinateSpace',p),id_data_coordspace,...
            'crypto:sha512',{sha512sum(spm_file(files.con{c},'cpath')),'xsd:string'},...
            });
        id = originalfile(p,files.con_orig{c},idContrast,nidm_conv('nidm_ContrastMap',p));
        p.wasDerivedFrom(idContrast,id);
        p.wasGeneratedBy(idContrast,idConEst);
        
        idSE = getid(['niiri:contrast_standard_error_map_id' postfix],isHumanReadable);
        p.entity(idSE,{...
            'prov:type',nidm_conv('nidm_ContrastStandardErrorMap',p),...
            'prov:location',{uri(spm_file(files.conse{c},'cpath')),'xsd:anyURI'},...
            'nfo:fileName',{spm_file(files.conse{c},'filename'),'xsd:string'},...
            'dct:format',niifmt,...
            'prov:label',{'Contrast Standard Error Map','xsd:string'},...
            nidm_conv('nidm_inCoordinateSpace',p),id_data_coordspace,...
            'crypto:sha512',{sha512sum(spm_file(files.conse{c},'cpath')),'xsd:string'},...
            });
        p.wasGeneratedBy(idSE,idConEst);
    elseif strcmp(this_stat_type, 'obo_Fstatistic')
        idEffMS = getid(['niiri:contrast_explained_mean_square_map_id' postfix],isHumanReadable);
        p.entity(idEffMS,{...
            'prov:type',nidm_conv('nidm_ContrastExplainedMeanSquareMap',p),...
            'prov:location',{uri(spm_file(files.effms{c},'cpath')),'xsd:anyURI'},...
            'nfo:fileName',{spm_file(files.effms{c},'filename'),'xsd:string'},...
            'dct:format',niifmt,...
            'prov:label',{'Contrast Explained Mean Square Map','xsd:string'},...
            nidm_conv('nidm_inCoordinateSpace',p),id_data_coordspace,...
            'crypto:sha512',{sha512sum(spm_file(files.effms{c},'cpath')),'xsd:string'},...
            });
        p.wasGeneratedBy(idEffMS,idConEst);
    end
end

%-Entity: Height Threshold
%--------------------------------------------------------------------------
idHeightThresh = getid('niiri:height_threshold_id',isHumanReadable);

idHeightThresh3 = getid('niiri:height_threshold_id_3',isHumanReadable);

extra_fields_height = {};

if isfield(inference, 'HeightThreshold_equivalentThreshold')
    equivHThresholds = inference.HeightThreshold_equivalentThreshold;
    for i = 1:numel(equivHThresholds)
        equivHThresh = equivHThresholds(i);

        idEquivHThresh = getid('niiri:height_threshold_id_' + num2str(i),isHumanReadable);

        extra_fields_height(end+1:end+2) = {
            nidm_conv('nidm_equivalentThreshold',p),idEquivHThresh,...
        };

        p.entity(idEquivHThresh,{...
            'prov:type',nidm_conv('nidm_HeightThreshold',p),...
            'prov:type',nidm_conv(equivHThresh.HeightThreshold_type, p),...
            ... %         'prov:label',{nidm_esc(equivHeightThreshNames{i}),'xsd:string'},...
            'prov:label',{'Height Threshold','xsd:string'},... 
            'prov:value',{equivHThresh.HeightThreshold_value,'xsd:float'},...
        });
    end
end

height_thresh_type = inference.HeightThreshold_type;
height_thresh_value = inference.HeightThreshold_value;
switch(height_thresh_type)
    case 'obo_FWERAdjustedPValue'
        height_thresh_desc  = sprintf(': p<%f (FWE)',height_thresh_value);
    case 'nidm_PValueUncorrected'
        height_thresh_desc  = sprintf(': p<%f (unc.)',height_thresh_value);
    case 'obo_QValue'
        height_thresh_desc  = sprintf(': p<%s (FDR)',height_thresh_value);
    case 'obo_Statistic'
        height_thresh_desc  = sprintf(': %s>%f',stat, height_thresh_value);
    otherwise
        error(['Unrecognised threshold type: ' height_thresh_type])
end

p.entity(idHeightThresh,{...
    'prov:type',nidm_conv('nidm_HeightThreshold',p),...
    'prov:type',nidm_conv(height_thresh_type, p),...
    'prov:label',{nidm_esc(['Height Threshold' height_thresh_desc]),'xsd:string'},...
    'prov:value',{height_thresh_value,'xsd:float'},...
    extra_fields_height{:}
    });

%-Entity: Extent Threshold
%--------------------------------------------------------------------------
if spm_get_defaults('stats.rft.nonstat')
    warning('Non-stationary RFT results not handled yet.');
end

extra_fields_extent = {};
if isfield(inference, 'ExtentThreshold_equivalentThreshold')
    equivEThresholds = inference.ExtentThreshold_equivalentThreshold;

    for i = 1:numel(equivEThresholds)
        equivEThresh = equivEThresholds(i);

        idEquivEThresh = getid('niiri:extent_threshold_id_' + num2str(i),isHumanReadable);

        extra_fields_extent(end+1:end+2) = {
            nidm_conv('nidm_equivalentThreshold',p),idEquivEThresh,...
        };

        p.entity(idEquivEThresh,{...
            'prov:type',nidm_conv('nidm_ExtentThreshold',p),...
            'prov:type',nidm_conv(equivEThresh.ExtentThreshold_type,p),...
            ... %         'prov:label',{nidm_esc(equivExtentThreshNames{i}),'xsd:string'},...
            'prov:label',{'Extent Threshold','xsd:string'},... 
            'prov:value',{equivEThresh.ExtentThreshold_value,'xsd:float'},...
            });
    end
end

extent_thresh_type = inference.ExtentThreshold_type;
switch(extent_thresh_type)
    case 'obo_FWERAdjustedPValue'
        extent_thresh_value = inference.ExtentThreshold_value;
        extent_thresh_desc  = sprintf(': p<%f (FWE)',extent_thresh_value);
        extra_fields_extent(end+1:end+2) = {
            'prov:value',extent_thresh_value,...
        };
    case 'nidm_PValueUncorrected'
        extent_thresh_value = inference.ExtentThreshold_value;
        extent_thresh_desc  = sprintf(': p<%f (unc.)',extent_thresh_value);
        extra_fields_extent(end+1:end+2) = {
            'prov:value',extent_thresh_value,...
        };
    case 'obo_QValue'
        extent_thresh_value = inference.ExtentThreshold_value;
        extent_thresh_desc  = sprintf(': p<%s (FDR)',extent_thresh_value);
        extra_fields_extent(end+1:end+2) = {
            'prov:value',extent_thresh_value,...
        };
    case 'obo_Statistic'
        extent_thresh_value = inference.ExtentThreshold_clusterSizeInVoxels;
        extent_thresh_desc  = sprintf(': k>=%d',extent_thresh_value);
        extra_fields_extent(end+1:end+2) = {
            nidm_conv('nidm_clusterSizeInVoxels',p),{extent_thresh_value,'xsd:int'},... 
        };
        if isfield(inference, 'ExtentThreshold_clusterSizeInResels')
            extra_fields_extent(end+1:end+2) = {
                nidm_conv('nidm_clusterSizeInResels',p),...
                {inference.ExtentThreshold_clusterSizeInResels,'xsd:float'},...
            };
        end
end

idExtentThresh = getid('niiri:extent_threshold_id',isHumanReadable);
p.entity(idExtentThresh,{...
    'prov:type',nidm_conv('nidm_ExtentThreshold',p),...
    'prov:type',nidm_conv(extent_thresh_type,p),...
    'prov:label',{['Extent Threshold' extent_thresh_desc],'xsd:string'},...
    extra_fields_extent{:}
    });

%-Entity: Peak Definition Criteria
%--------------------------------------------------------------------------
maxNumberOfPeaksPerCluster = NIDM.PeakDefinitionCriteria_maxNumberOfPeaksPerCluster;
minDistanceBetweenPeaks = NIDM.PeakDefinitionCriteria_minDistanceBetweenPeaks;
idPeakDefCrit = getid('niiri:peak_definition_criteria_id',isHumanReadable);
p.entity(idPeakDefCrit,{...
    'prov:type',nidm_conv('nidm_PeakDefinitionCriteria',p),...
    'prov:label',{'Peak Definition Criteria','xsd:string'},...
    nidm_conv('nidm_maxNumberOfPeaksPerCluster',p),{maxNumberOfPeaksPerCluster,'xsd:int'},...
    nidm_conv('nidm_minDistanceBetweenPeaks',p),{minDistanceBetweenPeaks,'xsd:float'},...
    });

%-Entity: Cluster Definition Criteria
%--------------------------------------------------------------------------
clusterConnectivityCriterion = NIDM.ClusterDefinitionCriteria_hasConnectivityCriterion; % see spm_max.m
idClusterDefCrit = getid('niiri:cluster_definition_criteria_id',isHumanReadable);

switch(clusterConnectivityCriterion)
    case 'nidm_voxel18connected'
        connValue = 18;
    case 'nidm_voxel26connected'
        connValue = 18;
    case 'nidm_voxel9connected'
        connValue = 9;
    otherwise
        error('Unknown connectivity value')
end

p.entity(idClusterDefCrit,{...
    'prov:type',nidm_conv('nidm_ClusterDefinitionCriteria',p),...
    'prov:label',{sprintf('Cluster Connectivity Criterion: %d',connValue),'xsd:string'},...
    nidm_conv('nidm_hasConnectivityCriterion',p),nidm_conv(clusterConnectivityCriterion,p),...
    });


%-Activity: Inference
%==========================================================================
if numel(con_name) == 1
    st = {'prov:type',nidm_conv('nidm_Inference',p), ...
          nidm_conv('nidm_hasAlternativeHypothesis',p),nidm_conv(inference.Inference_hasAlternativeHypothesis,p),...
          'prov:label','Inference'};
else
    switch(inference.Inference_type)
        case 'nidm_ConjunctionInference'
            st = {'prov:type',nidm_conv('nidm_ConjunctionInference',p), ...
              nidm_conv('nidm_hasAlternativeHypothesis',p),nidm_conv(inference.Inference_hasAlternativeHypothesis,p),...
              'prov:label','Conjunction Inference'};
        case 'spm_PartialConjunctionInference'
            partialConjDegree = inference.PartialConjunctionInference_partialConjunctionDegree;
            st = {'prov:type',nidm_conv('spm_PartialConjunctionInference',p), ...
              nidm_conv('nidm_hasAlternativeHypothesis',p),nidm_conv(inference.Inference_hasAlternativeHypothesis,p),...
              'prov:label','Partial Conjunction Inference', ...
              nidm_conv('spm_partialConjunctionDegree',p),{partialConjDegree,'xsd:int'}};
        otherwise
            error('Unknown conjunction type.');
    end
end

idInference = getid('niiri:inference_id',isHumanReadable);
p.activity(idInference,st);
p.wasAssociatedWith(idInference, idSoftware);
p.used(idInference, idHeightThresh);
p.used(idInference, idExtentThresh);
for c=1:numel(contrasts)
    p.used(idInference, idSPM{c});
end
if has_rpv
    p.used(idInference, idRPV);
end
p.used(idInference, idMask1);
p.used(idInference, idPeakDefCrit);
p.used(idInference, idClusterDefCrit);

%-Entity: Display Mask Maps
%--------------------------------------------------------------------------
if isfield(inference, 'DisplayMaskMap_atLocation')
    for i=1:numel(files.dmask)
        gunzip(files.dmask{i});
        V = spm_vol(strrep(files.dmask{i}, '.gz', ''));
        % In octave the gzipped version is not kept when using gunzip
        if ~strcmp(spm_check_version,'matlab')
            gzip(strrep(files.dmask{i}, '.gz', ''));
        end
        spm_unlink(strrep(files.dmask{i}, '.gz', ''))
        
        gunzip(files.tspm);
        V_ex = spm_vol(strrep(files.tspm, '.gz', ''));
        % In octave the gzipped version is not kept when using gunzip
        if ~strcmp(spm_check_version,'matlab')
            gzip(strrep(files.tspm, '.gz', ''));
        end
        spm_unlink(strrep(files.tspm, '.gz', ''))
        
        if ~spm_check_orientations(struct('dim',{V_ex.dim,V.dim},...
                'mat',{V_ex.mat,V.mat}),false)
            currCoordSpace = coordspace(p,V.mat,V.dim',units,coordsys);
        else
            currCoordSpace = id_data_coordspace;
        end

        if numel(files.dmask) == 1, postfix = '';
        else                        postfix = sprintf('_%d',i); end
        idDMask = getid(['niiri:display_mask_map_id' postfix],isHumanReadable);
        p.entity(idDMask,{...
            'prov:type',nidm_conv('nidm_DisplayMaskMap',p),...
            'prov:location',{uri(spm_file(files.dmask{i},'cpath')),'xsd:anyURI'},...
            'nfo:fileName',{spm_file(files.dmask{i},'filename'),'xsd:string'},...
            'dct:format',niifmt,...
            'prov:label',{'Display Mask Map','xsd:string'},...
            nidm_conv('nidm_inCoordinateSpace',p),currCoordSpace,...
            'crypto:sha512',{sha512sum(spm_file(files.dmask{i},'cpath')),'xsd:string'},...
            });
        id = originalfile(p,files.dmask{i},idDMask,nidm_conv('nidm_DisplayMaskMap',p));
        p.wasDerivedFrom(idDMask,id);
        p.used(idInference, idDMask);
    end
end

%-Entity: SVC Mask Map
%--------------------------------------------------------------------------
if isfield(inference, 'SubVolumeMap_atLocation')
    % TODO deal with SVC
    if ~isempty(files.svcmask)
        V = spm_vol(files.svcmask);
        if ~spm_check_orientations(struct('dim',{xSPM.DIM',V.dim},...
                'mat',{xSPM.M,V.mat}),false)
            currCoordSpace = coordspace(p,V.mat,V.dim',units,coordsys);
        else
            currCoordSpace = id_data_coordspace;
        end
        idSVC = getid('niiri:sub_volume_id',isHumanReadable);
        p.entity(idSVC,{...
            'prov:type','nidm:SubVolumeMap',...
            'prov:location',{uri(spm_file(files.svcmask,'cpath')),'xsd:anyURI'},...
            'nfo:fileName',{spm_file(files.svcmask,'filename'),'xsd:string'},...
            'dct:format',niifmt,...
            'prov:label',{'Sub-volume','xsd:string'},...
            nidm_conv('nidm_inCoordinateSpace',p),currCoordSpace,...
            'crypto:sha512',{sha512sum(spm_file(files.svcmask,'cpath')),'xsd:string'},...
            });
        id = originalfile(p,files.svcmask,idSVC,'nidm:SubVolumeMap');
        p.wasDerivedFrom(idSVC,id);
        p.used(idInference, idSVC);
    end
end

%-Entity: Search Space
%--------------------------------------------------------------------------
rftstat = inference.SearchSpaceMaskMap_randomFieldStationarity;

if rftstat
    rftstat_str = 'true';
else
    rftstat_str = 'false';
end

extra_fields_searchspace = {};
has_resels = false;
if isfield(inference, 'SearchSpaceMaskMap_reselSizeInVoxels')
    has_resels = true;
    extra_fields_searchspace(end+1:end+8) = {
            nidm_conv('nidm_reselSizeInVoxels',p),{inference.SearchSpaceMaskMap_reselSizeInVoxels,'xsd:float'},... 
            nidm_conv('nidm_searchVolumeInResels',p),{inference.SearchSpaceMaskMap_searchVolumeInResels,'xsd:float'},...
            nidm_conv('nidm_noiseFWHMInVoxels',p),{inference.SearchSpaceMaskMap_noiseFWHMInVoxels,'xsd:string'},...
            nidm_conv('nidm_noiseFWHMInUnits',p),{inference.SearchSpaceMaskMap_noiseFWHMInUnits,'xsd:string'},...
        };
end

if isfield(inference, 'SearchSpaceMaskMap_heightCriticalThresholdFWE05')
    extra_fields_searchspace(end+1:end+2) = {
            nidm_conv('nidm_heightCriticalThresholdFWE05',p),{inference.SearchSpaceMaskMap_heightCriticalThresholdFWE05,'xsd:float'},... 
        };
end
if isfield(inference, 'SearchSpaceMaskMap_heightCriticalThresholdFDR05')
    extra_fields_searchspace(end+1:end+2) = {
            nidm_conv('nidm_heightCriticalThresholdFDR05',p),{inference.SearchSpaceMaskMap_heightCriticalThresholdFDR05,'xsd:float'},... 
        };
end
if isfield(inference, 'SearchSpaceMaskMap_expectedNumberOfVoxelsPerCluster')
    extra_fields_searchspace(end+1:end+2) = {
            nidm_conv('nidm_expectedNumberOfVoxelsPerCluster',p),{inference.SearchSpaceMaskMap_expectedNumberOfVoxelsPerCluster,'xsd:float'},... 
        };
end
if isfield(inference, 'SearchSpaceMaskMap_expectedNumberOfClusters')
    extra_fields_searchspace(end+1:end+2) = {
            nidm_conv('nidm_expectedNumberOfClusters',p),{inference.SearchSpaceMaskMap_expectedNumberOfClusters,'xsd:float'},... 
        };
end
if isfield(inference, 'SearchSpaceMaskMap_searchVolumeReselsGeometry')
    extra_fields_searchspace(end+1:end+2) = {
            nidm_conv('spm_searchVolumeReselsGeometry',p),{inference.SearchSpaceMaskMap_searchVolumeReselsGeometry,'xsd:float'},... 
        };
end

idSearchSpace = getid('niiri:search_space_id',isHumanReadable);
search_space_attributes = {...
    'prov:type',nidm_conv('nidm_SearchSpaceMaskMap',p),...
    'prov:location',{uri(spm_file(files.searchspace,'cpath')),'xsd:anyURI'},...
    'nfo:fileName',{spm_file(files.searchspace,'filename'),'xsd:string'},...
    'dct:format',niifmt,...
    'prov:label',{'Search Space Mask Map','xsd:string'}...
    nidm_conv('nidm_inCoordinateSpace',p),id_data_coordspace,...
    nidm_conv('nidm_searchVolumeInVoxels',p),{inference.SearchSpaceMaskMap_searchVolumeInVoxels,'xsd:int'},...
    nidm_conv('nidm_searchVolumeInUnits',p),{inference.SearchSpaceMaskMap_searchVolumeInUnits,'xsd:float'},...
    extra_fields_searchspace{:},...
    nidm_conv('nidm_randomFieldStationarity',p),{rftstat_str, 'xsd:boolean'},...
    'crypto:sha512',{sha512sum(spm_file(files.searchspace,'cpath')),'xsd:string'},...
    };
if isfield(inference, 'SearchSpaceMaskMap_smallestSignificantClusterSizeInVoxelsFWE05')
    search_space_attributes = [search_space_attributes, {...
        nidm_conv('spm_smallestSignificantClusterSizeInVoxelsFWE05',p),...
        {inference.SearchSpaceMaskMap_smallestSignificantClusterSizeInVoxelsFWE05,'xsd:int'},...
        }];
end
if isfield(inference, 'SearchSpaceMaskMap_smallestSignificantClusterSizeInVoxelsFDR05')
    search_space_attributes = [search_space_attributes, {...
        nidm_conv('spm_smallestSignificantClusterSizeInVoxelsFDR05',p),...
        {inference.SearchSpaceMaskMap_smallestSignificantClusterSizeInVoxelsFDR05,'xsd:int'},...
        }];
end
p.entity(idSearchSpace,search_space_attributes);
p.wasGeneratedBy(idSearchSpace, idInference);

%-Entity: Excursion Set
%--------------------------------------------------------------------------
extra_fields_excset = {};
if isfield(inference, 'ExcursionSetMap_numberOfSupraThresholdClusters')
    c = inference.ExcursionSetMap_numberOfSupraThresholdClusters;
    pc = inference.ExcursionSetMap_pValue;
    extra_fields_excset(end+1:end+4) = {
            nidm_conv('nidm_numberOfSupraThresholdClusters',p),{c,'xsd:int'},...
            nidm_conv('nidm_pValue',p),{pc,'xsd:float'},...
    };
end

if has_mip
    idMaximumIntensityProjection = getid('niiri:maximum_intensity_projection_id',isHumanReadable);
    extra_fields_excset(end+1:end+2) = {
        nidm_conv('nidm_hasMaximumIntensityProjection',p),idMaximumIntensityProjection,...
    };
end

if has_clustlabelmap
    idClusterLabelsMap = getid('niiri:cluster_label_map_id',isHumanReadable);
    extra_fields_excset(end+1:end+2) = {
        nidm_conv('nidm_hasClusterLabelsMap',p),idClusterLabelsMap,...
    };
end

idExcursionSet = getid('niiri:excursion_set_map_id',isHumanReadable);
p.entity(idExcursionSet,{...
    'prov:type',nidm_conv('nidm_ExcursionSetMap',p),...
    'prov:location',{uri(spm_file(files.tspm,'cpath')),'xsd:anyURI'},...
    'nfo:fileName',{spm_file(files.tspm,'filename'),'xsd:string'},...
    'dct:format',niifmt,...
    'prov:label',{'Excursion Set Map','xsd:string'},...
    extra_fields_excset{:},...
    nidm_conv('nidm_inCoordinateSpace',p),id_data_coordspace,...
    'crypto:sha512',{sha512sum(spm_file(files.tspm,'cpath')),'xsd:string'},...
    });

% TODO: compute cluster label map if missing
if has_clustlabelmap
    p.entity(idClusterLabelsMap,{...
        'prov:type',nidm_conv('nidm_ClusterLabelsMap',p),...
        'prov:location',{uri(spm_file(files.clust,'cpath')),'xsd:anyURI'},...
        'nfo:fileName',{spm_file(files.clust,'filename'),'xsd:string'},...
        'dct:format',niifmt,...
        'prov:label',{'Cluster Labels Map','xsd:string'},...
        nidm_conv('nidm_inCoordinateSpace',p),id_data_coordspace,...
        'crypto:sha512',{sha512sum(spm_file(files.clust,'cpath')),'xsd:string'},...
        });
end

if has_mip
    p.entity(idMaximumIntensityProjection,{...
        'prov:type','dctype:Image',...
        'prov:location',{uri(spm_file(files.mip,'cpath')),'xsd:anyURI'},...
        'nfo:fileName',{spm_file(files.mip,'filename'),'xsd:string'},...
        'dct:format',{'image/png','xsd:string'}...
        });
end
p.wasGeneratedBy(idExcursionSet, idInference); 

%-Entity: Clusters
%--------------------------------------------------------------------------
clusters = inference.Clusters;
% clusters_names = inference('Clusters').keys;

% idx = find(~cellfun(@isempty,{TabDat.dat{:,5}}));
% idCluster = cell(1,numel(idx));
k = 1;
for i=1:numel(clusters)
    if iscell(clusters)
        this_cluster = clusters{i};
    else
        this_cluster = clusters(i);
    end
    
    iClus = sprintf('%04d',i);
    idCluster{i} = getid(['niiri:supra_threshold_cluster_' iClus],isHumanReadable);
    
    extra_clust = {};
    if has_resels
        extra_clust(end+1:end+2) = {...
            nidm_conv('nidm_clusterSizeInResels',p),{this_cluster.SupraThresholdCluster_clusterSizeInResels,'xsd:float'},...
            };
    end
    if isfield(this_cluster, 'SupraThresholdCluster_pValueUncorrected')
        extra_clust(end+1:end+2) = {...
            nidm_conv('nidm_pValueUncorrected',p),{this_cluster.SupraThresholdCluster_pValueUncorrected,'xsd:float'},...
            };
    end
    if isfield(this_cluster, 'SupraThresholdCluster_pValueFWER')
        extra_clust(end+1:end+2) = {...
            nidm_conv('nidm_pValueFWER',p),{this_cluster.SupraThresholdCluster_pValueFWER,'xsd:float'},...
            };
    end
    if isfield(this_cluster, 'SupraThresholdCluster_qValueFDR')
        extra_clust(end+1:end+2) = {...
            nidm_conv('nidm_qValueFDR',p),{this_cluster.SupraThresholdCluster_qValueFDR,'xsd:float'},...
            };
    end
    
    p.entity(idCluster{i},{...
        'prov:type',nidm_conv('nidm_SupraThresholdCluster',p),...
        'prov:label',{['Supra-Threshold Cluster: ' iClus],'xsd:string'},...
        nidm_conv('nidm_clusterSizeInVoxels',p),{this_cluster.SupraThresholdCluster_clusterSizeInVoxels,'xsd:int'},...
        extra_clust{:},...
        nidm_conv('nidm_clusterLabelId',p),{num2str(i),'xsd:int'},...
        });
    p.wasDerivedFrom(idCluster{i}, idExcursionSet);
    
    %-Entity: Peaks
    %----------------------------------------------------------------------
    peaks = this_cluster.Peaks;
    for j=1:numel(peaks)
        if iscell(peaks)
            my_peak = peaks{j};
        else
            my_peak = peaks(j);
        end
        
        iPeak  = num2str(k, '%04d');
        idPeak = getid(['niiri:peak_' iPeak],isHumanReadable);
        idCoordinate = getid(['niiri:coordinate_' iPeak],isHumanReadable);
        
        extra_peak = {};
        if isfield(my_peak, 'Peak_pValueUncorrected')
            extra_peak(end+1:end+4) = {...
                nidm_conv('nidm_pValueUncorrected',p),{my_peak.Peak_pValueUncorrected,'xsd:float'},...
                nidm_conv('nidm_equivalentZStatistic',p),{xsdfloat(my_peak.Peak_equivalentZStatistic),'xsd:float'},...
                };
        end
        if isfield(my_peak, 'Peak_pValueFWER')
            extra_peak(end+1:end+2) = {...
                nidm_conv('nidm_pValueFWER',p),{my_peak.Peak_pValueFWER,'xsd:float'},...
                };
        end
        if isfield(my_peak, 'Peak_qValueFDR')
            extra_peak(end+1:end+2) = {...
                nidm_conv('nidm_qValueFDR',p),{my_peak.Peak_qValueFDR,'xsd:float'},...
                };
        end

        p.entity(idPeak,{...
            'prov:type',nidm_conv('nidm_Peak',p),...
            'prov:label',{['Peak: ' iPeak],'xsd:string'},...
            'prov:location',idCoordinate,...
            'prov:value',{my_peak.Peak_value,'xsd:float'},...
            extra_peak{:},...
            });

        p.entity(idCoordinate,{...
            'prov:type','prov:Location',...
            'prov:type',nidm_conv('nidm_Coordinate',p),...
            'prov:label',{['Coordinate: ' iPeak],'xsd:string'},...
            nidm_conv('nidm_coordinateVector',p),{my_peak.Coordinate_coordinateVector,'xsd:string'},...
            });

        p.wasDerivedFrom(idPeak, idCluster{i});
        k = k + 1;
    end
end

pp.bundle(idResults,p);

%==========================================================================
%-                  P R O V   S E R I A L I Z A T I O N
%==========================================================================
%serialize(pp,fullfile(outdir,'nidm.provn'));
serialize(pp,fullfile(outdir,'nidm.ttl'));
serialize(pp,fullfile(outdir,'nidm.jsonld'));
%serialize(pp,fullfile(outdir,'nidm.json'));
%serialize(pp,fullfile(outdir,'nidm.pdf'));

i = 1;
while true
    nidmfile = fullfile(spm_fileparts(outdir),sprintf('%s_%04d.nidm.zip',lower(soft_label),i));
    if spm_existfile(nidmfile), i = i + 1; else, break; end
end
zip(nidmfile,'*',outdir);
rmdir(outdir,'s');

prov = pp;


%==========================================================================
% function str = html_esc(str)
%==========================================================================
function str = html_esc(str)
%-Escape
% See http://www.w3.org/TR/html4/charset.html#h-5.3.2
str = strrep(str,'&','&amp;');
str = strrep(str,'<','&lt;');
str = strrep(str,'>','&gt;');
str = strrep(str,'"','&quot;');


%==========================================================================
% function u = uri(u)
%==========================================================================
function u = uri(u)
%-File URI scheme
%if ispc, s='/'; else s=''; end
%u = ['file://' s strrep(spm_file(u,'cpath'),'\','/')];
e = ' ';
for i=1:length(e)
    u = strrep(u,e(i),['%' dec2hex(double(e(i)))]);
end
u = spm_file(u,'filename');


%==========================================================================
% function v = xsdfloat(v)
%==========================================================================
function v = xsdfloat(v)
% See http://books.xmlschemata.org/relaxng/ch19-77095.html
if numel(v) == 1 && isinf(v) && v > 0, v = 'INF';  end
if numel(v) == 1 && isinf(v) && v < 0, v = '-INF'; end
if numel(v) == 1 && isnan(v),          v = 'NaN';  end


%==========================================================================
% function checksum = sha512sum(file)
%==========================================================================
function checksum = sha512sum(file)
if strcmp(spm_check_version,'matlab')
    md   = java.security.MessageDigest.getInstance('SHA-512');
    file = spm_file(file,'cpath');
    fid  = fopen(file,'rb');
    if fid == -1, error('Cannot open "%s".',file); end
    md.update(fread(fid,Inf,'*uint8'));
    fclose(fid);
    checksum = typecast(md.digest,'uint8');
    checksum = lower(reshape(dec2hex(checksum)',1,[]));
else
    checksum = hash('sha512', fileread(spm_file(file,'cpath')));
end


%==========================================================================
% function checksum = md5sum(data)
%==========================================================================
function checksum = md5sum(data)
if ~nargin
    data = char(javaMethod('randomUUID','java.util.UUID'));
end
if strcmp(spm_check_version,'matlab')
    md = java.security.MessageDigest.getInstance('MD5');
    if ischar(data)
        md.update(uint8(data));
    else
        md.update(typecast(data,'uint8'));
    end
    checksum = typecast(md.digest,'uint8');
    checksum = lower(reshape(dec2hex(checksum)',1,[]));
else
    checksum = hash('md5', typecast(data,'char'));
end

%==========================================================================
% function img2nii(img,nii,xSPM)
%==========================================================================
function img2nii(img,nii,xSPM)

% If input and output are nii.gz then use a simple copy
if strcmp(spm_file(img, 'ext'), 'gz') && strcmp(spm_file(nii, 'ext'), 'gz')
    copyfile(img, nii);
else
    if nargin == 2, xSPM = struct; end
    if ~isfield(xSPM,'STAT'), xSPM.STAT = ''; end
    if ~isfield(xSPM,'fcn'), xSPM.fcn = @(x) x; end
    if nargin == 1, nii = spm_file(img,'ext','.nii'); end
    gz = strcmp(spm_file(nii,'ext'),'gz');
    if gz, nii = spm_file(nii,'ext',''); end
    ni     = nifti(img);
    no     = nifti;
    no.dat = file_array(nii,...
                        ni.dat.dim,...
                        ni.dat.dtype,...
                        0,...
                        ni.dat.scl_slope,...
                        ni.dat.scl_inter);
    no.mat  = ni.mat;
    no.mat_intent = ni.mat_intent;
    no.mat0 = ni.mat0;
    no.mat0_intent = ni.mat0_intent;
    no.descrip = ni.descrip;
    switch xSPM.STAT
        case 'T'
            no.intent.name  = ['spm' xSPM.STATstr];
            no.intent.code  = 3;
            no.intent.param = xSPM.df(2);
        case 'F'
            no.intent.name  = ['spm' xSPM.STATstr];
            no.intent.code  = 4;
            no.intent.param = xSPM.df;
        case 'con'
            no.intent.name  = 'SPM contrast';
            no.intent.code  = 1001;
    end
    create(no);
    no.dat(:,:,:) = xSPM.fcn(ni.dat(:,:,:));
    if gz
        gzip(nii);
        spm_unlink(nii);
    end
end


%==========================================================================
% function id = coordspace(p,M,DIM,units,coordsys,idx)
%==========================================================================
function id = coordspace(p,M,DIM,units,coordsys,idx)
persistent index
if nargin == 6
    index = idx;
else
    if isempty(index)
        index = 1;
    else
        index = index + 1;
    end
end
% Convert from first voxel at [1,1,1] to first voxel at [0,0,0]
v2wm = M * [eye(4,3) [1 1 1 1]'];
M    = M(1:3,1:3);
id = getid(['niiri:coordinate_space_id_' num2str(index)],isHumanReadable);
p.entity(id,{...
    'prov:type',nidm_conv('nidm_CoordinateSpace',p),...
    'prov:label',{['Coordinate space ' num2str(index)],'xsd:string'},...
    nidm_conv('nidm_voxelToWorldMapping',p),{v2wm,'xsd:string'},...
    nidm_conv('nidm_voxelUnits',p),{units,'xsd:string'},...
    nidm_conv('nidm_voxelSize',p),{sqrt(diag(M'*M))','xsd:string'},...
    nidm_conv('nidm_inWorldCoordinateSystem',p),coordsys,...
    nidm_conv('nidm_numberOfDimensions',p),{numel(DIM),'xsd:int'},...
    nidm_conv('nidm_dimensionsInVoxels',p),{DIM,'xsd:string'}
    });

%==========================================================================
% function id = originalfile(p,file,idx,typ)
%==========================================================================
function id = originalfile(p,file,idx,typ)
id = getid([idx '_der'],isHumanReadable);
p.entity(id,{...
    'prov:type',typ,...
    'nfo:fileName',{spm_file(file,'filename'),'xsd:string'},...
    'dct:format',{'image/nifti','xsd:string'},...
    'crypto:sha512',{sha512sum(spm_file(file,'cpath')),'xsd:string'},...
    });

%==========================================================================
% function id = getid(id,humanReadable,checksum)
%==========================================================================
function id = getid(id,humanReadable,checksum)
if ~humanReadable
    if nargin == 2
        id = md5sum;
    else
        id = md5sum(checksum);
    end
    id = ['niiri:' id];
end

%==========================================================================
% function i = isHumanReadable(i)
%==========================================================================
function i = isHumanReadable(i)
persistent isHR
if nargin, isHR = i; end
if isempty(isHR), error('Default not set.'); end
i = isHR;

%==========================================================================
% function out = nidm_conv(in,p)
%==========================================================================
function out = nidm_conv(in,p)
persistent C
if isempty(C), C = nidm_constants; end

i = find(ismember(C(:,2),in));
if ~isempty(i)
    out = [C{i,2} ':'];
    if nargin == 2
        prefix = '';
        qname = C{i,1};
        j = find(qname == ':');
        if ~isempty(j)
            prefix = qname(1:j(end)-1);
            qname = qname(j(end)+1:end);
        end
        % should instead use ns = p.get_namespace;
        switch prefix
            case 'nidm'
                url = 'http://purl.org/nidash/nidm#';
            case 'spm'
                url = 'http://purl.org/nidash/spm#';
            case 'obo'
                url = 'http://purl.obolibrary.org/obo/';
            case 'nlx'
                url = 'http://uri.neuinfo.org/nif/nifstd/';
            case 'scr'
                url = 'http://scicrunch.org/resolver/';
            otherwise
                warning('Unknown prefix "%s".',prefix);
                url = '';
        end
        p.add_namespace(C{i,2},[url qname]);
    end
else
    warning('Unknown element ''%s''.',in);
    out = in;
end

%==========================================================================
% function S = nidm_esc(S)
%==========================================================================
function S = nidm_esc(S)
S = strrep(S, sprintf('\n'), '\n');

%==========================================================================
% function nidm_store_constants
%==========================================================================
function nidm_store_constants
urlwrite('https://raw.githubusercontent.com/incf-nidash/nidm/master/nidm/nidm-results/terms/prefixes.csv','prefixes.csv');
C = reshape(textread('prefixes.csv','%s','delimiter',',','headerlines',1),2,[])';
fprintf('C = {...\n');
for i=1:size(C,1)
    fprintf('''%s'', ''%s'';...\n',C{i,1},strrep(C{i,2},':',''));
end
fprintf('};\n');

%==========================================================================
% function C = nidm_constants
%==========================================================================
function C = nidm_constants
% automatically generated by nidm_store_constants
C = {...
'obo:BFO_0000179', 'obo_BFOOWLSpecificationLabel';...
'obo:BFO_0000180', 'obo_BFOCLIFSpecificationLabel';...
'obo:IAO_0000002', 'obo_ExampleToBeEventuallyRemoved';...
'obo:IAO_0000111', 'obo_editorPreferredTerm';...
'obo:IAO_0000112', 'obo_exampleOfUsage';...
'obo:IAO_0000114', 'obo_hasCurationStatus';...
'obo:IAO_0000115', 'obo_definition';...
'obo:IAO_0000116', 'obo_editorNote';...
'obo:IAO_0000117', 'obo_termEditor';...
'obo:IAO_0000118', 'obo_alternativeTerm';...
'obo:IAO_0000119', 'obo_definitionSource';...
'obo:IAO_0000120', 'obo_MetadataComplete';...
'obo:IAO_0000121', 'obo_OrganizationalTerm';...
'obo:IAO_0000122', 'obo_ReadyForRelease';...
'obo:IAO_0000123', 'obo_MetadataIncomplete';...
'obo:IAO_0000124', 'obo_Uncurated';...
'obo:IAO_0000125', 'obo_PendingFinalVetting';...
'obo:IAO_0000136', 'obo_IsAbout';...
'obo:IAO_0000232', 'obo_curatorNote';...
'obo:IAO_0000412', 'obo_importedFrom';...
'obo:IAO_0000423', 'obo_ToBeReplacedWithExternalOntologyTerm';...
'obo:IAO_0000428', 'obo_RequiresDiscussion';...
'obo:IAO_0000600', 'obo_elucidation';...
'obo:OBI_0000251', 'obo_Cluster';...
'obo:OBI_0001265', 'obo_FWERAdjustedPValue';...
'obo:OBI_0001442', 'obo_QValue';...
'obo:STATO_0000030', 'obo_ChiSquaredStatistic';...
'obo:STATO_0000039', 'obo_Statistic';...
'obo:STATO_0000051', 'obo_Poissondistribution';...
'obo:STATO_0000067', 'obo_continuousProbabilityDistribution';...
'obo:STATO_0000117', 'obo_discreteProbabilityDistribution';...
'obo:STATO_0000119', 'obo_modelparameterestimation';...
'obo:STATO_0000129', 'obo_hasvalue';...
'obo:STATO_0000176', 'obo_TStatistic';...
'obo:STATO_0000193', 'obo_StudyGroupPopulation';...
'obo:STATO_0000225', 'obo_ProbabilityDistribution';...
'obo:STATO_0000227', 'obo_NormalDistribution';...
'obo:STATO_0000276', 'obo_BinomialDistribution';...
'obo:STATO_0000282', 'obo_FStatistic';...
'obo:STATO_0000323', 'obo_ContrastWeightMatrix';...
'obo:STATO_0000346', 'obo_CovarianceStructure';...
'obo:STATO_0000357', 'obo_ToeplitzCovarianceStructure';...
'obo:STATO_0000362', 'obo_CompoundSymmetryCovarianceStructure';...
'obo:STATO_0000370', 'obo_OrdinaryLeastSquaresEstimation';...
'obo:STATO_0000371', 'obo_WeightedLeastSquaresEstimation';...
'obo:STATO_0000372', 'obo_GeneralizedLeastSquaresEstimation';...
'obo:STATO_0000373', 'obo_IterativelyReweightedLeastSquaresEstimation';...
'obo:STATO_0000374', 'obo_FeasibleGeneralizedLeastSquaresEstimation';...
'obo:STATO_0000376', 'obo_ZStatistic';...
'obo:STATO_0000405', 'obo_UnstructuredCovarianceStructure';...
'iao:iao.owl', 'iao_IAORelease20150223';...
'dc:contributor', 'dc_Contributor';...
'dc:creator', 'dc_Creator';...
'dc:date', 'dc_Date';...
'dc:date', 'dc_Date';...
'dc:description', 'dc_Description';...
'dc:title', 'dc_Title';...
'fsl:FSL_0000001', 'fsl_FSLsGammaDifferenceHRF';...
'fsl:FSL_0000002', 'fsl_GaussianRunningLineDriftModel';...
'fsl:FSL_0000003', 'fsl_FSLsTemporalDerivative';...
'fsl:FSL_0000004', 'fsl_driftCutoffPeriod';...
'fsl:FSL_0000005', 'fsl_featVersion';...
'nidm:NIDM_0000001', 'nidm_ContrastEstimation';...
'nidm:NIDM_0000002', 'nidm_ContrastMap';...
'nidm:NIDM_0000004', 'nidm_BinaryMap';...
'nidm:NIDM_0000007', 'nidm_ClusterDefinitionCriteria';...
'nidm:NIDM_0000008', 'nidm_ClusterLabelsMap';...
'nidm:NIDM_0000009', 'nidm_Colin27CoordinateSystem';...
'nidm:NIDM_0000011', 'nidm_ConjunctionInference';...
'nidm:NIDM_0000012', 'nidm_ConnectivityCriterion';...
'nidm:NIDM_0000013', 'nidm_ContrastStandardErrorMap';...
'nidm:NIDM_0000015', 'nidm_Coordinate';...
'nidm:NIDM_0000016', 'nidm_CoordinateSpace';...
'nidm:NIDM_0000017', 'nidm_CustomCoordinateSystem';...
'nidm:NIDM_0000019', 'nidm_DesignMatrix';...
'nidm:NIDM_0000020', 'nidm_DisplayMaskMap';...
'nidm:NIDM_0000021', 'nidm_regressorNames';...
'nidm:NIDM_0000023', 'nidm_ErrorModel';...
'nidm:NIDM_0000024', 'nidm_ExchangeableError';...
'nidm:NIDM_0000025', 'nidm_ExcursionSetMap';...
'nidm:NIDM_0000026', 'nidm_ExtentThreshold';...
'nidm:NIDM_0000027', 'nidm_NIDMResults';...
'nidm:NIDM_0000028', 'nidm_FiniteImpulseResponseBasisSet';...
'nidm:NIDM_0000029', 'nidm_GammaDifferenceHRF';...
'nidm:NIDM_0000030', 'nidm_GammaBasisSet';...
'nidm:NIDM_0000031', 'nidm_GammaHRF';...
'nidm:NIDM_0000033', 'nidm_GrandMeanMap';...
'nidm:NIDM_0000034', 'nidm_HeightThreshold';...
'nidm:NIDM_0000035', 'nidm_HemodynamicResponseFunction';...
'nidm:NIDM_0000036', 'nidm_ConvolutionBasisSet';...
'nidm:NIDM_0000037', 'nidm_HemodynamicResponseFunctionDerivative';...
'nidm:NIDM_0000038', 'nidm_Icbm452AirCoordinateSystem';...
'nidm:NIDM_0000039', 'nidm_Icbm452Warp5CoordinateSystem';...
'nidm:NIDM_0000040', 'nidm_IcbmMni152LinearCoordinateSystem';...
'nidm:NIDM_0000041', 'nidm_IcbmMni152NonLinear2009aAsymmetricCoordinateSystem';...
'nidm:NIDM_0000042', 'nidm_IcbmMni152NonLinear2009aSymmetricCoordinateSystem';...
'nidm:NIDM_0000043', 'nidm_IcbmMni152NonLinear2009bAsymmetricCoordinateSystem';...
'nidm:NIDM_0000044', 'nidm_IcbmMni152NonLinear2009bSymmetricCoordinateSystem';...
'nidm:NIDM_0000045', 'nidm_IcbmMni152NonLinear2009cAsymmetricCoordinateSystem';...
'nidm:NIDM_0000046', 'nidm_IcbmMni152NonLinear2009cSymmetricCoordinateSystem';...
'nidm:NIDM_0000047', 'nidm_IcbmMni152NonLinear6thGenerationCoordinateSystem';...
'nidm:NIDM_0000048', 'nidm_IndependentError';...
'nidm:NIDM_0000049', 'nidm_Inference';...
'nidm:NIDM_0000050', 'nidm_Ixi549CoordinateSystem';...
'nidm:NIDM_0000051', 'nidm_MNICoordinateSystem';...
'nidm:NIDM_0000052', 'nidm_Map';...
'nidm:NIDM_0000053', 'nidm_MapHeader';...
'nidm:NIDM_0000054', 'nidm_MaskMap';...
'nidm:NIDM_0000055', 'nidm_Mni305CoordinateSystem';...
'nidm:NIDM_0000056', 'nidm_ModelParametersEstimation';...
'nidm:NIDM_0000057', 'nidm_NIDMObjectModel';...
'nidm:NIDM_0000059', 'nidm_NonParametricSymmetricDistribution';...
'nidm:NIDM_0000060', 'nidm_OneTailedTest';...
'nidm:NIDM_0000061', 'nidm_ParameterEstimateMap';...
'nidm:NIDM_0000062', 'nidm_Peak';...
'nidm:NIDM_0000063', 'nidm_PeakDefinitionCriteria';...
'nidm:NIDM_0000064', 'nidm_PixelConnectivityCriterion';...
'nidm:NIDM_0000066', 'nidm_ResidualMeanSquaresMap';...
'nidm:NIDM_0000067', 'nidm_CustomBasisSet';...
'nidm:NIDM_0000068', 'nidm_SearchSpaceMaskMap';...
'nidm:NIDM_0000069', 'nidm_FourierBasisSet';...
'nidm:NIDM_0000070', 'nidm_SupraThresholdCluster';...
'nidm:NIDM_0000071', 'nidm_ErrorParameterMapWiseDependence';...
'nidm:NIDM_0000072', 'nidm_ConstantParameter';...
'nidm:NIDM_0000073', 'nidm_IndependentParameter';...
'nidm:NIDM_0000074', 'nidm_RegularizedParameter';...
'nidm:NIDM_0000075', 'nidm_StandardizedCoordinateSystem';...
'nidm:NIDM_0000076', 'nidm_StatisticMap';...
'nidm:NIDM_0000077', 'nidm_SubjectCoordinateSystem';...
'nidm:NIDM_0000078', 'nidm_TalairachCoordinateSystem';...
'nidm:NIDM_0000079', 'nidm_TwoTailedTest';...
'nidm:NIDM_0000080', 'nidm_VoxelConnectivityCriterion';...
'nidm:NIDM_0000081', 'nidm_WorldCoordinateSystem';...
'nidm:NIDM_0000082', 'nidm_clusterLabelId';...
'nidm:NIDM_0000083', 'nidm_clusterSizeInVertices';...
'nidm:NIDM_0000084', 'nidm_clusterSizeInVoxels';...
'nidm:NIDM_0000085', 'nidm_contrastName';...
'nidm:NIDM_0000086', 'nidm_coordinateVector';...
'nidm:NIDM_0000087', 'nidm_DriftModel';...
'nidm:NIDM_0000088', 'nidm_hasDriftModel';...
'nidm:NIDM_0000089', 'nidm_dependenceMapWiseDependence';...
'nidm:NIDM_0000090', 'nidm_dimensionsInVoxels';...
'nidm:NIDM_0000091', 'nidm_effectDegreesOfFreedom';...
'nidm:NIDM_0000092', 'nidm_equivalentZStatistic';...
'nidm:NIDM_0000093', 'nidm_errorDegreesOfFreedom';...
'nidm:NIDM_0000094', 'nidm_errorVarianceHomogeneous';...
'nidm:NIDM_0000096', 'nidm_grandMeanScaling';...
'nidm:NIDM_0000097', 'nidm_hasAlternativeHypothesis';...
'nidm:NIDM_0000098', 'nidm_hasClusterLabelsMap';...
'nidm:NIDM_0000099', 'nidm_hasConnectivityCriterion';...
'nidm:NIDM_0000100', 'nidm_hasErrorDependence';...
'nidm:NIDM_0000101', 'nidm_hasErrorDistribution';...
'nidm:NIDM_0000102', 'nidm_hasHRFBasis';...
'nidm:NIDM_0000103', 'nidm_hasMapHeader';...
'nidm:NIDM_0000104', 'nidm_inCoordinateSpace';...
'nidm:NIDM_0000105', 'nidm_inWorldCoordinateSystem';...
'nidm:NIDM_0000106', 'nidm_isUserDefined';...
'nidm:NIDM_0000107', 'nidm_maskedMedian';...
'nidm:NIDM_0000108', 'nidm_maxNumberOfPeaksPerCluster';...
'nidm:NIDM_0000109', 'nidm_minDistanceBetweenPeaks';...
'nidm:NIDM_0000110', 'nidm_GaussianHRF';...
'nidm:NIDM_0000111', 'nidm_numberOfSupraThresholdClusters';...
'nidm:NIDM_0000112', 'nidm_numberOfDimensions';...
'nidm:NIDM_0000113', 'nidm_objectModel';...
'nidm:NIDM_0000114', 'nidm_pValue';...
'nidm:NIDM_0000115', 'nidm_pValueFWER';...
'nidm:NIDM_0000116', 'nidm_pValueUncorrected';...
'nidm:NIDM_0000117', 'nidm_pixel4connected';...
'nidm:NIDM_0000118', 'nidm_pixel8connected';...
'nidm:NIDM_0000119', 'nidm_qValueFDR';...
'nidm:NIDM_0000120', 'nidm_randomFieldStationarity';...
'nidm:NIDM_0000121', 'nidm_searchVolumeInVoxels';...
'nidm:NIDM_0000122', 'nidm_softwareVersion';...
'nidm:NIDM_0000123', 'nidm_statisticType';...
'nidm:NIDM_0000124', 'nidm_targetIntensity';...
'nidm:NIDM_0000126', 'nidm_varianceMapWiseDependence';...
'nidm:NIDM_0000127', 'nidm_version';...
'nidm:NIDM_0000128', 'nidm_voxel18connected';...
'nidm:NIDM_0000129', 'nidm_voxel26connected';...
'nidm:NIDM_0000130', 'nidm_voxel6connected';...
'nidm:NIDM_0000131', 'nidm_voxelSize';...
'nidm:NIDM_0000132', 'nidm_voxelToWorldMapping';...
'nidm:NIDM_0000133', 'nidm_voxelUnits';...
'nidm:NIDM_0000134', 'nidm_withEstimationMethod';...
'nidm:NIDM_0000135', 'nidm_ContrastVarianceMap';...
'nidm:NIDM_0000136', 'nidm_searchVolumeInUnits';...
'nidm:NIDM_0000137', 'nidm_searchVolumeInVertices';...
'nidm:NIDM_0000138', 'nidm_hasMaximumIntensityProjection';...
'nidm:NIDM_0000139', 'nidm_coordinateVectorInVoxels';...
'nidm:NIDM_0000140', 'nidm_ClusterCenterOfGravity';...
'nidm:NIDM_0000141', 'nidm_expectedNumberOfClusters';...
'nidm:NIDM_0000142', 'nidm_expectedNumberOfVerticesPerCluster';...
'nidm:NIDM_0000143', 'nidm_expectedNumberOfVoxelsPerCluster';...
'nidm:NIDM_0000144', 'nidm_ReselsPerVoxelMap';...
'nidm:NIDM_0000145', 'nidm_noiseRoughnessInVoxels';...
'nidm:NIDM_0000146', 'nidm_heightCriticalThresholdFDR05';...
'nidm:NIDM_0000147', 'nidm_heightCriticalThresholdFWE05';...
'nidm:NIDM_0000148', 'nidm_reselSizeInVoxels';...
'nidm:NIDM_0000149', 'nidm_searchVolumeInResels';...
'nidm:NIDM_0000150', 'nidm_LinearSplineBasisSet';...
'nidm:NIDM_0000151', 'nidm_SineBasisSet';...
'nidm:NIDM_0000156', 'nidm_clusterSizeInResels';...
'nidm:NIDM_0000157', 'nidm_noiseFWHMInUnits';...
'nidm:NIDM_0000158', 'nidm_noiseFWHMInVertices';...
'nidm:NIDM_0000159', 'nidm_noiseFWHMInVoxels';...
'nidm:NIDM_0000160', 'nidm_PValueUncorrected';...
'nidm:NIDM_0000161', 'nidm_equivalentThreshold';...
'nidm:NIDM_0000162', 'nidm_Threshold';...
'nidm:NIDM_0000163', 'nidm_ContrastExplainedMeanSquareMap';...
'nidm:NIDM_0000164', 'nidm_NeuroimagingAnalysisSoftware';...
'nidm:NIDM_0000165', 'nidm_NIDMResultsExporter';...
'nidm:NIDM_0000166', 'nidm_NIDMResultsExport';...
'nidm:NIDM_0000167', 'nidm_nidmfsl';...
'nidm:NIDM_0000168', 'nidm_spm_results_nidm';...
'nidm:NIDM_0000169', 'nidm_Data';...
'nidm:NIDM_0000170', 'nidm_groupName';...
'nidm:NIDM_0000171', 'nidm_numberOfSubjects';...
'nidm:NIDM_0000172', 'nidm_hasMRIProtocol';...
'spm:SPM_0000001', 'spm_SPMsDriftCutoffPeriod';...
'spm:SPM_0000002', 'spm_DiscreteCosineTransformbasisDriftModel';...
'spm:SPM_0000003', 'spm_SPMsDispersionDerivative';...
'spm:SPM_0000004', 'spm_SPMsCanonicalHRF';...
'spm:SPM_0000005', 'spm_PartialConjunctionInference';...
'spm:SPM_0000006', 'spm_SPMsTemporalDerivative';...
'spm:SPM_0000010', 'spm_searchVolumeReselsGeometry';...
'spm:SPM_0000011', 'spm_smallestSignificantClusterSizeInVerticesFDR05';...
'spm:SPM_0000012', 'spm_smallestSignificantClusterSizeInVerticesFWE05';...
'spm:SPM_0000013', 'spm_smallestSignificantClusterSizeInVoxelsFDR05';...
'spm:SPM_0000014', 'spm_smallestSignificantClusterSizeInVoxelsFWE05';...
'spm:SPM_0000015', 'spm_partialConjunctionDegree';...
'prv:PropertyReification', 'prv_PropertyReification';...
'prv:object_property', 'prv_hasobjectproperty';...
'prv:reification_class', 'prv_hasreificationclass';...
'prv:shortcut', 'prv_hasshortcut';...
'prv:shortcut_property', 'prv_hasshortcutproperty';...
'prv:subject_property', 'prv_hassubjectproperty';...
'scr:SCR_002823', 'scr_FSL';...
'scr:SCR_007037', 'scr_SPM';...
'scr:SCR_002092', 'scr_SnPM';...
'nlx:birnlex_2094', 'nlx_ImagingInstrument';...
'nlx:birnlex_2100', 'nlx_MagneticResonanceImagingScanner';...
'nlx:birnlex_2177', 'nlx_MRIProtocol';...
'nlx:birnlex_2250', 'nlx_FunctionalMRIProtocol';...
'nlx:birnlex_2251', 'nlx_StructuralMRIProtocol';...
'nlx:ixl_0050000', 'nlx_PositronEmissionTomographyScanner';...
'nlx:ixl_0050001', 'nlx_SinglePhotonEmissionComputedTomographyScanner';...
'nlx:ixl_0050002', 'nlx_MagnetoencephalographyMachine';...
'nlx:ixl_0050003', 'nlx_ElectroencephalographyMachine';...
'nlx:ixl_0050004', 'nlx_AnatomicalMRIProtocol';...
'nlx:nlx_inv_20090249', 'nlx_DiffusionWeightedImagingProtocol';...
};

